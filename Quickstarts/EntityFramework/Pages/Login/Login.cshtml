@page
@using Newtonsoft.Json
@model Core.Pages.Login.LoginModel
@Html.AntiForgeryToken()  

<h2>Please use your authenticator</h2>

<script>
    //Authentication Configuration
    //https://www.identityserver.com/documentation/fido2/webauthn/authentication/
    
    // Challenge
    let challengeBytesAsString = atob("@Html.Raw(Model.FidoChallenge!.Base64Challenge)");
    let challenge = new Uint8Array(challengeBytesAsString.length);
    for (let i = 0; i < challengeBytesAsString.length; i++) {
        challenge[i] = challengeBytesAsString.charCodeAt(i);
    }

    // Relying Party ID
    let rpId = "@Model.FidoChallenge.RelyingPartyId";

    // Allowed credentials
    let keys = JSON.parse('@Html.Raw(JsonConvert.SerializeObject(Model.FidoChallenge.Base64KeyIds))');
    let allowCredentials = [];

    // Allow for user not to specify the username
    if ( keys != null ) {
        for (let i = 0; i < keys.length; i++) {
            let keyIdBytesAsString = window.atob(keys[i]);

            let key = new Uint8Array(keyIdBytesAsString.length);
            for (let i = 0; i < keyIdBytesAsString.length; i++) {
                key[i] = keyIdBytesAsString.charCodeAt(i);
            }

            allowCredentials.push({
                type: "public-key",
                id: key
            });
        }
    }
    
    // Attestation Preference
    // direct: the RelyingParty wants to receive the attestation statement as generated by the authenticator. direct is the recommended value.
    // indirect: the RelyingParty prefers a verifiable attestation statement but allows the client to device how to obtain it.
    // none: the relying party is not interested in authenticator attestation.
    var attestation = "direct";

    var authenticatorSelection = {
        //The type of authenticator to use
        // cross-platform: roaming security authenticator (External authenticator)
        // platform: platform authenticator (Built in authenticator)
        authenticatorAttachment: 'cross-platform', 
        
        // Require resident key
        // Keys are generated and stored on the device
        // Not all authenticators support resident keys
        requireResidentKey: false,
        
        // discouraged: the RelyingParty does not want user verification during the operation, this could be to minimize disruption to the user flow.
        // preferred: the RelyingParty prefers user verification if possible but will not fail the if the response does have the AuthenticatorDataFlags.UV set.
        // required: the operation will fail if the response does have the AuthenticatorDataFlags.UV set.
        userVerification: 'preferred'
    };

    navigator.credentials.get({ publicKey: { challenge, rpId, allowCredentials } })
        .then((result) => {
            
            // base64 encode array buffers
            let encodedResult = {
                id: result.id,
                rawId: btoa(String.fromCharCode.apply(null, new Uint8Array(result.rawId))),
                type: result.type,
                response: {
                    authenticatorData:
                        btoa(String.fromCharCode.apply(null, new Uint8Array(result.response.authenticatorData))),
                    signature:
                        btoa(String.fromCharCode.apply(null, new Uint8Array(result.response.signature))),
                    userHandle:
                        btoa(String.fromCharCode.apply(null, new Uint8Array(result.response.userHandle))),
                    clientDataJSON:
                        btoa(String.fromCharCode.apply(null, new Uint8Array(result.response.clientDataJSON)))
                }
            };
            
            // post to login callback endpoint and redirect to homepage
            $.ajax({
                url: '/Login/Login',
                type: 'POST',
                contentType: 'application/json',
                data: JSON.stringify(encodedResult),
                beforeSend: function (xhr) { xhr.setRequestHeader("XSRF-TOKEN", $('input:hidden[name="__RequestVerificationToken"]').val()); },
                success:function() {
                    window.location.href = "/";
                }
            });
        })
        .catch((error) => {
            console.error(error);
        });
</script>